#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
üé® Canvas Editor v3.0 - Sistema de Handles Profesional
Inspirado en Canva Web

Autor: Canvas Editor Team
Fecha: 2025-01-15
"""

import sys
import os
import math
from enum import Enum
from dataclasses import dataclass
from typing import Optional, Tuple, List

from PyQt6.QtWidgets import *
from PyQt6.QtCore import *
from PyQt6.QtGui import *
from PIL import Image, ImageQt

# ==================== CONSTANTES ====================

DPI = 96

def cm_to_px(cm, dpi=DPI):
    return (cm / 2.54) * dpi

def px_to_cm(px, dpi=DPI):
    return (px / dpi) * 2.54

# ==================== ENUMS Y DATACLASSES ====================

class HandleType(Enum):
    """Tipos de handles disponibles"""
    CORNER_NW = "corner_nw"  # Noroeste (top-left)
    CORNER_NE = "corner_ne"  # Noreste (top-right)
    CORNER_SW = "corner_sw"  # Suroeste (bottom-left)
    CORNER_SE = "corner_se"  # Sureste (bottom-right)
    SIDE_N = "side_n"        # Norte (top)
    SIDE_S = "side_s"        # Sur (bottom)
    SIDE_E = "side_e"        # Este (right)
    SIDE_W = "side_w"        # Oeste (left)
    ROTATION = "rotation"    # Rotaci√≥n

@dataclass
class HandleConfig:
    """Configuraci√≥n visual de handles"""
    size: int = 12
    color: str = "#FFFFFF"
    border_color: str = "#0078D7"
    border_width: int = 2
    hover_scale: float = 1.4
    rotation_distance: int = 40
    rotation_color: str = "#4CAF50"

@dataclass
class Transform:
    """Datos de transformaci√≥n"""
    x: float = 0
    y: float = 0
    width: float = 100
    height: float = 100
    rotation: float = 0
    
# ==================== UTILIDADES MATEM√ÅTICAS ====================

class MathUtils:
    """Utilidades matem√°ticas para transformaciones"""
    
    @staticmethod
    def rotate_point(point: QPointF, center: QPointF, angle_degrees: float) -> QPointF:
        """Rotar un punto alrededor de un centro"""
        angle_rad = math.radians(angle_degrees)
        cos_a = math.cos(angle_rad)
        sin_a = math.sin(angle_rad)
        
        dx = point.x() - center.x()
        dy = point.y() - center.y()
        
        new_x = center.x() + dx * cos_a - dy * sin_a
        new_y = center.y() + dx * sin_a + dy * cos_a
        
        return QPointF(new_x, new_y)
    
    @staticmethod
    def distance(p1: QPointF, p2: QPointF) -> float:
        """Distancia entre dos puntos"""
        dx = p2.x() - p1.x()
        dy = p2.y() - p1.y()
        return math.sqrt(dx * dx + dy * dy)
    
    @staticmethod
    def angle_between_points(center: QPointF, point: QPointF) -> float:
        """√Ångulo en grados desde centro hasta punto"""
        dx = point.x() - center.x()
        dy = point.y() - center.y()
        return math.degrees(math.atan2(dy, dx))
    
    @staticmethod
    def snap_angle(angle: float, snap_threshold: float = 15) -> float:
        """Ajustar √°ngulo a m√∫ltiplos de 15¬∞"""
        snap_angles = [0, 15, 30, 45, 60, 75, 90, 105, 120, 135, 150, 165, 180,
                      195, 210, 225, 240, 255, 270, 285, 300, 315, 330, 345, 360]
        
        # Normalizar √°ngulo a 0-360
        normalized = angle % 360
        
        for snap in snap_angles:
            if abs(normalized - snap) < snap_threshold:
                return snap
        
        return angle

# ==================== HANDLE INDIVIDUAL ====================

class Handle(QGraphicsEllipseItem):
    """Handle individual para transformaci√≥n"""
    
    def __init__(self, handle_type: HandleType, config: HandleConfig, parent):
        super().__init__(parent)
        self.handle_type = handle_type
        self.config = config
        self.parent_item = parent
        self.is_hovered = False
        
        # Configuraci√≥n visual
        self.base_size = config.size
        self.setRect(-self.base_size/2, -self.base_size/2, 
                     self.base_size, self.base_size)
        
        # Z-index alto para estar encima
        self.setZValue(2000)
        
        # Flags
        self.setFlag(QGraphicsItem.GraphicsItemFlag.ItemIsMovable, False)
        self.setFlag(QGraphicsItem.GraphicsItemFlag.ItemIsSelectable, False)
        self.setAcceptHoverEvents(True)
        
        # Colores
        if handle_type == HandleType.ROTATION:
            self.normal_color = QColor(config.rotation_color)
            self.hover_color = QColor(config.rotation_color).lighter(120)
        else:
            self.normal_color = QColor(config.color)
            self.hover_color = QColor(config.color).darker(110)
        
        self.update_appearance()
    
    def update_appearance(self, hovered: bool = False):
        """Actualizar apariencia del handle"""
        self.is_hovered = hovered
        
        # Tama√±o
        size = self.base_size
        if hovered:
            size *= self.config.hover_scale
        
        self.setRect(-size/2, -size/2, size, size)
        
        # Color de relleno
        color = self.hover_color if hovered else self.normal_color
        self.setBrush(QBrush(color))
        
        # Borde
        pen = QPen(QColor(self.config.border_color))
        pen.setWidth(self.config.border_width)
        pen.setCosmetic(True)
        self.setPen(pen)
    
    def get_cursor(self) -> Qt.CursorShape:
        """Obtener cursor apropiado"""
        cursor_map = {
            HandleType.CORNER_NW: Qt.CursorShape.SizeFDiagCursor,
            HandleType.CORNER_NE: Qt.CursorShape.SizeBDiagCursor,
            HandleType.CORNER_SW: Qt.CursorShape.SizeBDiagCursor,
            HandleType.CORNER_SE: Qt.CursorShape.SizeFDiagCursor,
            HandleType.SIDE_N: Qt.CursorShape.SizeVerCursor,
            HandleType.SIDE_S: Qt.CursorShape.SizeVerCursor,
            HandleType.SIDE_E: Qt.CursorShape.SizeHorCursor,
            HandleType.SIDE_W: Qt.CursorShape.SizeHorCursor,
            HandleType.ROTATION: Qt.CursorShape.CrossCursor
        }
        return cursor_map.get(self.handle_type, Qt.CursorShape.ArrowCursor)
    
    def hoverEnterEvent(self, event):
        """Mouse entra al handle"""
        self.update_appearance(hovered=True)
        self.setCursor(self.get_cursor())
        super().hoverEnterEvent(event)
    
    def hoverLeaveEvent(self, event):
        """Mouse sale del handle"""
        self.update_appearance(hovered=False)
        super().hoverLeaveEvent(event)
    
    def mousePressEvent(self, event):
        """Click en el handle"""
        if event.button() == Qt.MouseButton.LeftButton:
            self.parent_item.start_transform(self.handle_type, event.scenePos())
        event.accept()
    
    def mouseMoveEvent(self, event):
        """Arrastrar el handle"""
        self.parent_item.update_transform(self.handle_type, event.scenePos())
        event.accept()
    
    def mouseReleaseEvent(self, event):
        """Soltar el handle"""
        self.parent_item.end_transform(self.handle_type)
        event.accept()

# ==================== TOOLTIP ====================

class TransformTooltip(QGraphicsTextItem):
    """Tooltip para mostrar dimensiones/√°ngulo"""
    
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setZValue(3000)
        self.setDefaultTextColor(QColor("white"))
        
        # Fondo
        self.background = QGraphicsRectItem(self)
        self.background.setBrush(QBrush(QColor(45, 45, 45, 220)))
        self.background.setPen(QPen(QColor("#0078D7"), 1))
        self.background.setZValue(-1)
        
        self.hide()
    
    def show_dimensions(self, width: float, height: float, pos: QPointF):
        """Mostrar dimensiones"""
        text = f"{int(width)} √ó {int(height)} px"
        self.setPlainText(text)
        self.setPos(pos.x() - 40, pos.y() - 40)
        
        # Actualizar fondo
        rect = self.boundingRect()
        self.background.setRect(rect.adjusted(-5, -5, 5, 5))
        
        self.show()
    
    def show_angle(self, angle: float, pos: QPointF):
        """Mostrar √°ngulo"""
        text = f"{int(angle) % 360}¬∞"
        self.setPlainText(text)
        self.setPos(pos.x() - 20, pos.y() - 40)
        
        rect = self.boundingRect()
        self.background.setRect(rect.adjusted(-5, -5, 5, 5))
        
        self.show()

# ==================== ELEMENTO DE IMAGEN CON HANDLES ====================

class ImageItem(QGraphicsPixmapItem):
    """Elemento de imagen con sistema de handles profesional"""
    
    def __init__(self, pixmap: QPixmap, image_path: str, editor):
        super().__init__(pixmap)
        self.image_path = image_path
        self.editor = editor
        self.original_pixmap = pixmap
        
        # Configuraci√≥n
        self.setFlag(QGraphicsItem.GraphicsItemFlag.ItemIsMovable, True)
        self.setFlag(QGraphicsItem.GraphicsItemFlag.ItemIsSelectable, True)
        self.setFlag(QGraphicsItem.GraphicsItemFlag.ItemSendsGeometryChanges, True)
        self.setTransformOriginPoint(self.boundingRect().center())
        
        # Aspect ratio original
        self.original_aspect_ratio = pixmap.width() / pixmap.height() if pixmap.height() > 0 else 1.0
        
        # Transform data
        self.transform_data = Transform(
            x=0, y=0,
            width=pixmap.width(),
            height=pixmap.height(),
            rotation=0
        )
        
        # Sistema de handles
        self.config = HandleConfig()
        self.handles = {}
        self.rotation_line = None
        self.tooltip = None
        self.create_handles()
        
        # Estado de transformaci√≥n
        self.active_handle = None
        self.transform_start_pos = None
        self.transform_start_data = None
        self.transform_start_mouse = None
        
        self.update_handles_visibility()
    
    def create_handles(self):
        """Crear todos los handles"""
        # Handles de esquinas
        for handle_type in [HandleType.CORNER_NW, HandleType.CORNER_NE,
                           HandleType.CORNER_SW, HandleType.CORNER_SE]:
            handle = Handle(handle_type, self.config, self)
            self.handles[handle_type] = handle
        
        # Handles de lados
        for handle_type in [HandleType.SIDE_N, HandleType.SIDE_S,
                           HandleType.SIDE_E, HandleType.SIDE_W]:
            handle = Handle(handle_type, self.config, self)
            self.handles[handle_type] = handle
        
        # Handle de rotaci√≥n
        rot_handle = Handle(HandleType.ROTATION, self.config, self)
        self.handles[HandleType.ROTATION] = rot_handle
        
        # L√≠nea de rotaci√≥n
        self.rotation_line = QGraphicsLineItem(self)
        pen = QPen(QColor(self.config.rotation_color))
        pen.setStyle(Qt.PenStyle.DashLine)
        pen.setWidth(2)
        pen.setCosmetic(True)
        self.rotation_line.setPen(pen)
        self.rotation_line.setZValue(1999)
        
        # Tooltip
        self.tooltip = TransformTooltip()
        self.editor.scene.addItem(self.tooltip)
        
        self.update_handles_position()
    
    def update_handles_position(self):
        """Actualizar posici√≥n de todos los handles"""
        rect = self.boundingRect()
        
        # Posiciones base
        positions = {
            HandleType.CORNER_NW: rect.topLeft(),
            HandleType.CORNER_NE: rect.topRight(),
            HandleType.CORNER_SW: rect.bottomLeft(),
            HandleType.CORNER_SE: rect.bottomRight(),
            HandleType.SIDE_N: QPointF(rect.center().x(), rect.top()),
            HandleType.SIDE_S: QPointF(rect.center().x(), rect.bottom()),
            HandleType.SIDE_E: QPointF(rect.right(), rect.center().y()),
            HandleType.SIDE_W: QPointF(rect.left(), rect.center().y())
        }
        
        # Actualizar handles
        for handle_type, pos in positions.items():
            if handle_type in self.handles:
                self.handles[handle_type].setPos(pos)
        
        # Handle de rotaci√≥n
        top_center = QPointF(rect.center().x(), rect.top())
        rotation_pos = QPointF(rect.center().x(), 
                              rect.top() - self.config.rotation_distance)
        self.handles[HandleType.ROTATION].setPos(rotation_pos)
        
        # L√≠nea de rotaci√≥n
        self.rotation_line.setLine(
            top_center.x(), top_center.y(),
            rotation_pos.x(), rotation_pos.y()
        )
    
    def update_handles_visibility(self):
        """Mostrar/ocultar handles seg√∫n selecci√≥n"""
        visible = self.isSelected()
        
        for handle in self.handles.values():
            handle.setVisible(visible)
        
        if self.rotation_line:
            self.rotation_line.setVisible(visible)
        
        if self.tooltip:
            if not visible:
                self.tooltip.hide()
    
    def itemChange(self, change, value):
        """Detectar cambios en el item"""
        if change == QGraphicsItem.GraphicsItemChange.ItemSelectedChange:
            QTimer.singleShot(0, self.update_handles_visibility)
        elif change == QGraphicsItem.GraphicsItemChange.ItemPositionHasChanged:
            self.transform_data.x = value.x()
            self.transform_data.y = value.y()
        
        return super().itemChange(change, value)
    
    # ==================== SISTEMA DE TRANSFORMACI√ìN ====================
    
    def start_transform(self, handle_type: HandleType, scene_pos: QPointF):
        """Iniciar transformaci√≥n"""
        self.active_handle = handle_type
        self.transform_start_pos = self.pos()
        self.transform_start_mouse = scene_pos
        
        # Guardar estado inicial
        self.transform_start_data = Transform(
            x=self.transform_data.x,
            y=self.transform_data.y,
            width=self.transform_data.width,
            height=self.transform_data.height,
            rotation=self.transform_data.rotation
        )
    
    def update_transform(self, handle_type: HandleType, scene_pos: QPointF):
        """Actualizar transformaci√≥n durante arrastre"""
        if not self.active_handle or not self.transform_start_data:
            return
        
        # Obtener modificadores
        modifiers = QApplication.keyboardModifiers()
        shift_pressed = modifiers & Qt.KeyboardModifier.ShiftModifier
        alt_pressed = modifiers & Qt.KeyboardModifier.AltModifier
        
        if handle_type == HandleType.ROTATION:
            self.perform_rotation(scene_pos, shift_pressed)
        else:
            self.perform_resize(handle_type, scene_pos, shift_pressed, alt_pressed)
    
    def end_transform(self, handle_type: HandleType):
        """Finalizar transformaci√≥n"""
        self.active_handle = None
        self.transform_start_pos = None
        self.transform_start_data = None
        self.transform_start_mouse = None
        
        if self.tooltip:
            self.tooltip.hide()
    
    def perform_rotation(self, scene_pos: QPointF, snap: bool):
        """Realizar rotaci√≥n"""
        # Centro del item en coordenadas de escena
        center = self.sceneBoundingRect().center()
        
        # Calcular √°ngulo
        angle = MathUtils.angle_between_points(center, scene_pos)
        
        # Ajustar para que 0¬∞ sea arriba
        angle = (angle + 90) % 360
        
        # Snap si Shift est√° presionado
        if snap:
            angle = MathUtils.snap_angle(angle)
        
        # Aplicar rotaci√≥n
        self.setRotation(angle)
        self.transform_data.rotation = angle
        
        # Mostrar tooltip
        if self.tooltip:
            self.tooltip.show_angle(angle, scene_pos)
    
    def perform_resize(self, handle_type: HandleType, scene_pos: QPointF, 
                      keep_aspect: bool, free_transform: bool):
        """Realizar redimensi√≥n"""
        # Convertir a coordenadas locales
        local_pos = self.mapFromScene(scene_pos)
        local_start = self.mapFromScene(self.transform_start_mouse)
        
        # Delta
        delta = local_pos - local_start
        
        # Datos iniciales
        start_data = self.transform_start_data
        rect = QRectF(0, 0, start_data.width, start_data.height)
        new_width = start_data.width
        new_height = start_data.height
        new_x = start_data.x
        new_y = start_data.y
        
        # ===== HANDLES DE ESQUINAS =====
        if handle_type in [HandleType.CORNER_NW, HandleType.CORNER_NE,
                          HandleType.CORNER_SW, HandleType.CORNER_SE]:
            
            # Determinar signos seg√∫n esquina
            if handle_type == HandleType.CORNER_SE:
                # Esquina inferior derecha
                new_width = start_data.width + delta.x()
                new_height = start_data.height + delta.y()
                
            elif handle_type == HandleType.CORNER_NW:
                # Esquina superior izquierda
                new_width = start_data.width - delta.x()
                new_height = start_data.height - delta.y()
                new_x = start_data.x + delta.x()
                new_y = start_data.y + delta.y()
                
            elif handle_type == HandleType.CORNER_NE:
                # Esquina superior derecha
                new_width = start_data.width + delta.x()
                new_height = start_data.height - delta.y()
                new_y = start_data.y + delta.y()
                
            elif handle_type == HandleType.CORNER_SW:
                # Esquina inferior izquierda
                new_width = start_data.width - delta.x()
                new_height = start_data.height + delta.y()
                new_x = start_data.x + delta.x()
            
            # Mantener aspect ratio (por defecto en esquinas, o con Shift)
            if not free_transform:
                # Usar el cambio mayor para mantener proporci√≥n
                width_change = abs(new_width - start_data.width)
                height_change = abs(new_height - start_data.height)
                
                if width_change > height_change:
                    new_height = new_width / self.original_aspect_ratio
                else:
                    new_width = new_height * self.original_aspect_ratio
                
                # Ajustar posici√≥n si es necesario
                if handle_type == HandleType.CORNER_NW:
                    new_x = start_data.x + (start_data.width - new_width)
                    new_y = start_data.y + (start_data.height - new_height)
                elif handle_type == HandleType.CORNER_NE:
                    new_y = start_data.y + (start_data.height - new_height)
                elif handle_type == HandleType.CORNER_SW:
                    new_x = start_data.x + (start_data.width - new_width)
        
        # ===== HANDLES DE LADOS =====
        else:
            if handle_type == HandleType.SIDE_E:
                new_width = start_data.width + delta.x()
            elif handle_type == HandleType.SIDE_W:
                new_width = start_data.width - delta.x()
                new_x = start_data.x + delta.x()
            elif handle_type == HandleType.SIDE_S:
                new_height = start_data.height + delta.y()
            elif handle_type == HandleType.SIDE_N:
                new_height = start_data.height - delta.y()
                new_y = start_data.y + delta.y()
        
        # Tama√±o m√≠nimo
        new_width = max(20, new_width)
        new_height = max(20, new_height)
        
        # Aplicar cambios
        scaled_pixmap = self.original_pixmap.scaled(
            int(new_width),
            int(new_height),
            Qt.AspectRatioMode.IgnoreAspectRatio,
            Qt.TransformationMode.SmoothTransformation
        )
        self.setPixmap(scaled_pixmap)
        
        # Actualizar posici√≥n
        self.setPos(new_x, new_y)
        
        # Actualizar transform data
        self.transform_data.width = new_width
        self.transform_data.height = new_height
        self.transform_data.x = new_x
        self.transform_data.y = new_y
        
        # Actualizar handles
        self.update_handles_position()
        
        # Mostrar tooltip
        if self.tooltip:
            self.tooltip.show_dimensions(new_width, new_height, scene_pos)
    
    def paint(self, painter, option, widget=None):
        """Pintar item con borde de selecci√≥n"""
        super().paint(painter, option, widget)
        
        if self.isSelected():
            pen = QPen(QColor("#0078D7"))
            pen.setWidth(2)
            pen.setCosmetic(True)
            painter.setPen(pen)
            painter.setBrush(Qt.BrushStyle.NoBrush)
            painter.drawRect(self.boundingRect())
    
    def mousePressEvent(self, event):
        """Click en el item (no en handle)"""
        if self.active_handle:
            event.accept()
            return
        super().mousePressEvent(event)
    
    def mouseMoveEvent(self, event):
        """Mover item"""
        if self.active_handle:
            event.accept()
            return
        super().mouseMoveEvent(event)
# ==================== EDITOR PRINCIPAL ====================

class CanvasEditor(QMainWindow):
    """Editor de Canvas v3.0 con sistema de handles profesional"""
    
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Canvas Editor v3.0 - Handles Profesionales")
        self.setGeometry(100, 100, 1600, 900)
        
        # Variables
        self.canvas_width_cm = 21.0
        self.canvas_height_cm = 29.7
        self.canvas_dpi = 96
        self.zoom_level = 1.0
        self.loaded_images = []
        
        # Crear interfaz
        self.setup_ui()
        self.create_canvas()
        self.apply_style()
        
        self.statusBar().showMessage(
            "‚ú® Canvas Editor v3.0 - Handles Profesionales | "
            "üîµ Esquinas: proporci√≥n | üîµ Lados: libre | "
            "üü¢ Verde: rotar | Shift: snap 15¬∞ | Alt: deformar",
            10000
        )
    
    def setup_ui(self):
        """Configurar interfaz"""
        central = QWidget()
        self.setCentralWidget(central)
        
        main_layout = QHBoxLayout(central)
        main_layout.setContentsMargins(0, 0, 0, 0)
        main_layout.setSpacing(0)
        
        # Panel izquierdo
        left_panel = self.create_left_panel()
        main_layout.addWidget(left_panel)
        
        # √Årea central
        canvas_area = self.create_canvas_area()
        main_layout.addWidget(canvas_area, stretch=1)
        
        # Panel derecho
        right_panel = self.create_right_panel()
        main_layout.addWidget(right_panel)
        
        # Men√∫
        self.create_menu_bar()
    
    def create_left_panel(self):
        """Panel izquierdo"""
        panel = QWidget()
        panel.setFixedWidth(280)
        panel.setStyleSheet("background-color: #F8F9FA;")
        
        layout = QVBoxLayout(panel)
        layout.setContentsMargins(10, 10, 10, 10)
        
        title = QLabel("üìê Elementos")
        title.setStyleSheet("font-size: 18px; font-weight: bold; color: #333;")
        layout.addWidget(title)
        
        layout.addSpacing(10)
        
        # Bot√≥n cargar
        load_btn = QPushButton("üìÅ Cargar Im√°genes")
        load_btn.setStyleSheet("""
            QPushButton {
                background-color: #0078D7;
                color: white;
                border: none;
                padding: 12px;
                border-radius: 6px;
                font-size: 14px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #005FA3;
            }
        """)
        load_btn.clicked.connect(self.load_images)
        layout.addWidget(load_btn)
        
        layout.addSpacing(10)
        
        # Info con fondo llamativo
        info = QLabel(
            "üí° <b>C√≥mo usar los handles:</b><br><br>"
            "üîµ <b>Esquinas azules:</b><br>"
            "   ‚Ä¢ Arrastra ‚Üí mantiene proporci√≥n<br>"
            "   ‚Ä¢ Alt + arrastrar ‚Üí deforma libre<br><br>"
            "üîµ <b>Lados azules:</b><br>"
            "   ‚Ä¢ Arrastra ‚Üí estira en esa direcci√≥n<br><br>"
            "üü¢ <b>Handle verde (arriba):</b><br>"
            "   ‚Ä¢ Arrastra ‚Üí rota la imagen<br>"
            "   ‚Ä¢ Shift + arrastrar ‚Üí snap 15¬∞"
        )
        info.setWordWrap(True)
        info.setStyleSheet("""
            QLabel {
                background: qlineargradient(
                    x1:0, y1:0, x2:0, y2:1,
                    stop:0 #E3F2FD,
                    stop:1 #BBDEFB
                );
                color: #0D47A1;
                padding: 15px;
                border-radius: 8px;
                border: 2px solid #0078D7;
                font-size: 11px;
                line-height: 18px;
            }
        """)
        layout.addWidget(info)
        
        layout.addSpacing(10)
        
        # Lista de im√°genes
        list_label = QLabel("Im√°genes cargadas:")
        list_label.setStyleSheet("font-weight: bold; color: #333;")
        layout.addWidget(list_label)
        
        self.images_list = QListWidget()
        self.images_list.setStyleSheet("""
            QListWidget {
                border: 1px solid #E0E0E0;
                border-radius: 5px;
                background: white;
            }
            QListWidget::item {
                padding: 8px;
                border-bottom: 1px solid #F0F0F0;
            }
            QListWidget::item:hover {
                background: #F5F5F5;
            }
            QListWidget::item:selected {
                background: #E3F2FD;
                color: #0078D7;
            }
        """)
        self.images_list.setIconSize(QSize(60, 60))
        self.images_list.itemClicked.connect(self.on_image_clicked)
        layout.addWidget(self.images_list)
        
        return panel
    
    def create_right_panel(self):
        """Panel derecho - Capas"""
        panel = QWidget()
        panel.setFixedWidth(280)
        panel.setStyleSheet("background-color: #F8F9FA;")
        
        layout = QVBoxLayout(panel)
        layout.setContentsMargins(10, 10, 10, 10)
        
        title = QLabel("üóÇÔ∏è Capas")
        title.setStyleSheet("font-size: 18px; font-weight: bold; color: #333;")
        layout.addWidget(title)
        
        layout.addSpacing(10)
        
        # Lista de capas
        self.layers_list = QListWidget()
        self.layers_list.setStyleSheet("""
            QListWidget {
                border: 1px solid #E0E0E0;
                border-radius: 5px;
                background: white;
            }
            QListWidget::item {
                padding: 10px;
                border-bottom: 1px solid #F0F0F0;
            }
            QListWidget::item:hover {
                background: #F5F5F5;
            }
            QListWidget::item:selected {
                background: #E3F2FD;
                color: #0078D7;
            }
        """)
        self.layers_list.itemClicked.connect(self.on_layer_clicked)
        layout.addWidget(self.layers_list)
        
        # Botones de orden
        order_layout = QHBoxLayout()
        
        up_btn = QPushButton("‚¨ÜÔ∏è Frente")
        up_btn.clicked.connect(self.bring_to_front)
        order_layout.addWidget(up_btn)
        
        down_btn = QPushButton("‚¨áÔ∏è Atr√°s")
        down_btn.clicked.connect(self.send_to_back)
        order_layout.addWidget(down_btn)
        
        layout.addLayout(order_layout)
        
        # Info de transformaci√≥n
        layout.addSpacing(10)
        
        self.transform_info = QLabel("Selecciona un elemento")
        self.transform_info.setWordWrap(True)
        self.transform_info.setStyleSheet("""
            QLabel {
                background: white;
                padding: 10px;
                border-radius: 5px;
                border: 1px solid #E0E0E0;
                font-size: 11px;
                color: #666;
            }
        """)
        layout.addWidget(self.transform_info)
        
        return panel
    
    def create_canvas_area(self):
        """√Årea del canvas"""
        widget = QWidget()
        widget.setStyleSheet("background-color: #E5E5E5;")
        
        layout = QVBoxLayout(widget)
        layout.setContentsMargins(20, 20, 20, 20)
        
        # Toolbar
        toolbar = self.create_toolbar()
        layout.addWidget(toolbar)
        
        # Vista del canvas - SIN RubberBand
        self.view = QGraphicsView()
        self.view.setRenderHint(QPainter.RenderHint.Antialiasing)
        self.view.setRenderHint(QPainter.RenderHint.SmoothPixmapTransform)
        self.view.setDragMode(QGraphicsView.DragMode.NoDrag)
        self.view.setStyleSheet("""
            QGraphicsView {
                border: none;
                background-color: #E5E5E5;
            }
        """)
        
        # Escena
        self.scene = QGraphicsScene()
        self.view.setScene(self.scene)
        
        # Conectar se√±al de selecci√≥n
        self.scene.selectionChanged.connect(self.on_selection_changed)
        
        layout.addWidget(self.view)
        
        # Controles de zoom
        zoom_controls = self.create_zoom_controls()
        layout.addWidget(zoom_controls)
        
        return widget
    
    def create_toolbar(self):
        """Toolbar del canvas"""
        toolbar = QWidget()
        toolbar.setFixedHeight(60)
        toolbar.setStyleSheet("background-color: white; border-radius: 8px;")
        
        layout = QHBoxLayout(toolbar)
        layout.setContentsMargins(15, 5, 15, 5)
        
        # T√≠tulo
        title = QLabel("üé® Canvas Editor v3.0")
        title.setStyleSheet("font-size: 16px; font-weight: bold; color: #333;")
        layout.addWidget(title)
        
        layout.addStretch()
        
        # Bot√≥n duplicar
        duplicate_btn = QPushButton("üìã Duplicar (Ctrl+D)")
        duplicate_btn.setStyleSheet(self.get_tool_button_style())
        duplicate_btn.clicked.connect(self.duplicate_selected)
        layout.addWidget(duplicate_btn)
        
        # Bot√≥n eliminar
        delete_btn = QPushButton("üóëÔ∏è Eliminar (Del)")
        delete_btn.setStyleSheet(self.get_tool_button_style())
        delete_btn.clicked.connect(self.delete_selected)
        layout.addWidget(delete_btn)
        
        return toolbar
    
    def create_zoom_controls(self):
        """Controles de zoom"""
        widget = QWidget()
        widget.setFixedHeight(40)
        
        layout = QHBoxLayout(widget)
        layout.setContentsMargins(0, 0, 0, 0)
        
        layout.addStretch()
        
        zoom_out = QPushButton("‚àí")
        zoom_out.setFixedSize(35, 35)
        zoom_out.setStyleSheet(self.get_zoom_button_style())
        zoom_out.clicked.connect(lambda: self.change_zoom(-0.1))
        layout.addWidget(zoom_out)
        
        self.zoom_label = QLabel("100%")
        self.zoom_label.setFixedWidth(60)
        self.zoom_label.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.zoom_label.setStyleSheet("""
            background: white;
            border-radius: 5px;
            padding: 5px;
            font-weight: bold;
        """)
        layout.addWidget(self.zoom_label)
        
        zoom_in = QPushButton("+")
        zoom_in.setFixedSize(35, 35)
        zoom_in.setStyleSheet(self.get_zoom_button_style())
        zoom_in.clicked.connect(lambda: self.change_zoom(0.1))
        layout.addWidget(zoom_in)
        
        layout.addSpacing(10)
        
        fit_btn = QPushButton("‚ä° Ajustar")
        fit_btn.setStyleSheet(self.get_zoom_button_style())
        fit_btn.clicked.connect(self.fit_to_view)
        layout.addWidget(fit_btn)
        
        layout.addStretch()
        
        return widget
    
    def create_menu_bar(self):
        """Men√∫ superior"""
        menubar = self.menuBar()
        
        # Archivo
        file_menu = menubar.addMenu("Archivo")
        
        new_action = QAction("Nuevo", self)
        new_action.setShortcut("Ctrl+N")
        new_action.triggered.connect(self.new_project)
        file_menu.addAction(new_action)
        
        file_menu.addSeparator()
        
        export_png = QAction("Exportar PNG...", self)
        export_png.triggered.connect(self.export_png)
        file_menu.addAction(export_png)
        
        file_menu.addSeparator()
        
        exit_action = QAction("Salir", self)
        exit_action.setShortcut("Ctrl+Q")
        exit_action.triggered.connect(self.close)
        file_menu.addAction(exit_action)
        
        # Editar
        edit_menu = menubar.addMenu("Editar")
        
        duplicate_action = QAction("Duplicar", self)
        duplicate_action.setShortcut("Ctrl+D")
        duplicate_action.triggered.connect(self.duplicate_selected)
        edit_menu.addAction(duplicate_action)
        
        delete_action = QAction("Eliminar", self)
        delete_action.setShortcut("Delete")
        delete_action.triggered.connect(self.delete_selected)
        edit_menu.addAction(delete_action)
        
        # Ver
        view_menu = menubar.addMenu("Ver")
        
        zoom_in_action = QAction("Acercar", self)
        zoom_in_action.setShortcut("Ctrl++")
        zoom_in_action.triggered.connect(lambda: self.change_zoom(0.1))
        view_menu.addAction(zoom_in_action)
        
        zoom_out_action = QAction("Alejar", self)
        zoom_out_action.setShortcut("Ctrl+-")
        zoom_out_action.triggered.connect(lambda: self.change_zoom(-0.1))
        view_menu.addAction(zoom_out_action)
        
        fit_action = QAction("Ajustar", self)
        fit_action.setShortcut("Ctrl+0")
        fit_action.triggered.connect(self.fit_to_view)
        view_menu.addAction(fit_action)
        
        # Ayuda
        help_menu = menubar.addMenu("Ayuda")
        
        about_action = QAction("Acerca de", self)
        about_action.triggered.connect(self.show_about)
        help_menu.addAction(about_action)
    
    def create_canvas(self):
        """Crear canvas"""
        self.scene.clear()
        
        width_px = cm_to_px(self.canvas_width_cm, self.canvas_dpi)
        height_px = cm_to_px(self.canvas_height_cm, self.canvas_dpi)
        
        self.canvas_rect = QGraphicsRectItem(0, 0, width_px, height_px)
        self.canvas_rect.setBrush(QBrush(QColor("white")))
        self.canvas_rect.setPen(QPen(QColor("#CCCCCC"), 1))
        self.canvas_rect.setZValue(-1000)
        self.scene.addItem(self.canvas_rect)
        
        margin = 100
        self.scene.setSceneRect(
            -margin, -margin,
            width_px + margin * 2,
            height_px + margin * 2
        )
        
        QTimer.singleShot(100, self.fit_to_view)
    
    # ==================== FUNCIONES DE IM√ÅGENES ====================
    
    def load_images(self):
        """Cargar im√°genes"""
        file_paths, _ = QFileDialog.getOpenFileNames(
            self,
            "Seleccionar Im√°genes",
            "",
            "Im√°genes (*.png *.jpg *.jpeg *.bmp *.gif)"
        )
        
        if not file_paths:
            return
        
        for path in file_paths:
            if path not in self.loaded_images:
                self.loaded_images.append(path)
                self.add_image_to_list(path)
        
        self.statusBar().showMessage(f"‚úÖ {len(file_paths)} imagen(es) cargada(s)", 2000)
    
    def add_image_to_list(self, image_path):
        """Agregar a la lista"""
        item = QListWidgetItem(os.path.basename(image_path))
        item.setData(Qt.ItemDataRole.UserRole, image_path)
        
        try:
            pixmap = QPixmap(image_path)
            if not pixmap.isNull():
                thumbnail = pixmap.scaled(
                    60, 60,
                    Qt.AspectRatioMode.KeepAspectRatio,
                    Qt.TransformationMode.SmoothTransformation
                )
                item.setIcon(QIcon(thumbnail))
        except:
            pass
        
        self.images_list.addItem(item)
    
    def on_image_clicked(self, item):
        """Click en imagen"""
        image_path = item.data(Qt.ItemDataRole.UserRole)
        self.add_image_to_canvas(image_path)
    
    def add_image_to_canvas(self, image_path):
        """Agregar imagen al canvas"""
        try:
            pil_img = Image.open(image_path)
            
            if pil_img.mode == 'RGBA':
                qimg = ImageQt.ImageQt(pil_img)
                pixmap = QPixmap.fromImage(qimg)
            else:
                pil_img_rgb = pil_img.convert('RGB')
                data = pil_img_rgb.tobytes("raw", "RGB")
                qimg = QImage(
                    data,
                    pil_img_rgb.width,
                    pil_img_rgb.height,
                    QImage.Format.Format_RGB888
                )
                pixmap = QPixmap.fromImage(qimg)
            
            # Escalar si es muy grande
            if pixmap.width() > 600 or pixmap.height() > 600:
                pixmap = pixmap.scaled(
                    600, 600,
                    Qt.AspectRatioMode.KeepAspectRatio,
                    Qt.TransformationMode.SmoothTransformation
                )
            
            # Crear item
            image_item = ImageItem(pixmap, image_path, self)
            
            # Centrar en vista
            view_center = self.view.mapToScene(
                self.view.viewport().rect().center()
            )
            
            image_item.setPos(
                view_center.x() - pixmap.width() / 2,
                view_center.y() - pixmap.height() / 2
            )
            
            self.scene.addItem(image_item)
            
            # Seleccionar
            self.scene.clearSelection()
            image_item.setSelected(True)
            
            self.update_layers_list()
            
            self.statusBar().showMessage(
                f"‚úÖ Imagen agregada: {os.path.basename(image_path)}", 
                2000
            )
            
        except Exception as e:
            QMessageBox.warning(self, "Error", f"No se pudo agregar:\n{str(e)}")
    
    # ==================== FUNCIONES DE EDICI√ìN ====================
    
    def delete_selected(self):
        """Eliminar seleccionados"""
        selected = self.scene.selectedItems()
        
        if not selected:
            return
        
        for item in selected:
            if isinstance(item, ImageItem):
                # Eliminar tooltip tambi√©n
                if hasattr(item, 'tooltip') and item.tooltip:
                    self.scene.removeItem(item.tooltip)
                self.scene.removeItem(item)
        
        self.update_layers_list()
        self.statusBar().showMessage(f"üóëÔ∏è {len(selected)} eliminado(s)", 2000)
    
    def duplicate_selected(self):
        """Duplicar seleccionados"""
        selected = self.scene.selectedItems()
        
        if not selected:
            return
        
        self.scene.clearSelection()
        
        for item in selected:
            if isinstance(item, ImageItem):
                # Crear duplicado
                new_item = ImageItem(item.original_pixmap, item.image_path, self)
                
                # Copiar propiedades
                new_item.setPos(item.pos() + QPointF(20, 20))
                new_item.setRotation(item.rotation())
                new_item.setPixmap(item.pixmap())
                
                # Copiar transform data
                new_item.transform_data = Transform(
                    x=item.transform_data.x + 20,
                    y=item.transform_data.y + 20,
                    width=item.transform_data.width,
                    height=item.transform_data.height,
                    rotation=item.transform_data.rotation
                )
                
                self.scene.addItem(new_item)
                new_item.setSelected(True)
        
        self.update_layers_list()
        self.statusBar().showMessage(f"üìã {len(selected)} duplicado(s)", 2000)
    
    def bring_to_front(self):
        """Traer al frente"""
        selected = self.scene.selectedItems()
        if not selected:
            return
        
        for item in selected:
            if isinstance(item, ImageItem):
                item.setZValue(item.zValue() + 1)
        
        self.update_layers_list()
    
    def send_to_back(self):
        """Enviar atr√°s"""
        selected = self.scene.selectedItems()
        if not selected:
            return
        
        for item in selected:
            if isinstance(item, ImageItem):
                item.setZValue(item.zValue() - 1)
        
        self.update_layers_list()
    
    # ==================== CAPAS ====================
    
    def update_layers_list(self):
        """Actualizar lista de capas"""
        self.layers_list.clear()
        
        items = [item for item in self.scene.items() 
                if isinstance(item, ImageItem)]
        
        items.sort(key=lambda x: x.zValue(), reverse=True)
        
        for item in items:
            name = os.path.basename(item.image_path)
            list_item = QListWidgetItem(f"üñºÔ∏è {name}")
            list_item.setData(Qt.ItemDataRole.UserRole, item)
            
            if item.isSelected():
                list_item.setBackground(QColor("#E3F2FD"))
            
            self.layers_list.addItem(list_item)
    
    def on_layer_clicked(self, item):
        """Click en capa"""
        image_item = item.data(Qt.ItemDataRole.UserRole)
        if image_item:
            self.scene.clearSelection()
            image_item.setSelected(True)
    
    def on_selection_changed(self):
        """Cambio de selecci√≥n"""
        self.update_layers_list()
        self.update_transform_info()
    
    def update_transform_info(self):
        """Actualizar info de transformaci√≥n"""
        selected = self.scene.selectedItems()
        
        if not selected or not isinstance(selected[0], ImageItem):
            self.transform_info.setText("Selecciona un elemento")
            return
        
        item = selected[0]
        data = item.transform_data
        
        info = (
            f"üìê <b>Dimensiones:</b><br>"
            f"   {int(data.width)} √ó {int(data.height)} px<br><br>"
            f"üîÑ <b>Rotaci√≥n:</b><br>"
            f"   {int(data.rotation) % 360}¬∞<br><br>"
            f"üìç <b>Posici√≥n:</b><br>"
            f"   X: {int(data.x)}, Y: {int(data.y)}"
        )
        
        self.transform_info.setText(info)
    
    # ==================== ZOOM ====================
    
    def change_zoom(self, delta):
        """Cambiar zoom"""
        self.zoom_level += delta
        self.zoom_level = max(0.1, min(3.0, self.zoom_level))
        
        self.view.resetTransform()
        self.view.scale(self.zoom_level, self.zoom_level)
        
        self.zoom_label.setText(f"{int(self.zoom_level * 100)}%")
    
    def fit_to_view(self):
        """Ajustar a vista"""
        self.view.fitInView(
            self.canvas_rect,
            Qt.AspectRatioMode.KeepAspectRatio
        )
        
        transform = self.view.transform()
        self.zoom_level = transform.m11()
        self.zoom_label.setText(f"{int(self.zoom_level * 100)}%")
    
    def wheelEvent(self, event):
        """Zoom con Ctrl+Scroll"""
        if event.modifiers() & Qt.KeyboardModifier.ControlModifier:
            delta = 0.1 if event.angleDelta().y() > 0 else -0.1
            self.change_zoom(delta)
            event.accept()
        else:
            super().wheelEvent(event)
    
    # ==================== PROYECTO ====================
    
    def new_project(self):
        """Nuevo proyecto"""
        reply = QMessageBox.question(
            self,
            "Nuevo Proyecto",
            "¬øCrear nuevo proyecto?",
            QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
        )
        
        if reply == QMessageBox.StandardButton.Yes:
            self.scene.clear()
            self.loaded_images.clear()
            self.images_list.clear()
            self.create_canvas()
            self.statusBar().showMessage("üìÑ Nuevo proyecto", 2000)
    
    def export_png(self):
        """Exportar a PNG"""
        file_path, _ = QFileDialog.getSaveFileName(
            self,
            "Guardar como PNG",
            "",
            "PNG (*.png)"
        )
        
        if not file_path:
            return
        
        if not file_path.endswith('.png'):
            file_path += '.png'
        
        try:
            rect = self.canvas_rect.rect()
            
            image = QImage(
                int(rect.width()),
                int(rect.height()),
                QImage.Format.Format_ARGB32
            )
            image.fill(Qt.GlobalColor.white)
            
            painter = QPainter(image)
            painter.setRenderHint(QPainter.RenderHint.Antialiasing)
            self.scene.render(painter, QRectF(image.rect()), rect)
            painter.end()
            
            image.save(file_path, 'PNG')
            
            self.statusBar().showMessage(f"‚úÖ Exportado: {os.path.basename(file_path)}", 3000)
            QMessageBox.information(self, "√âxito", f"Guardado en:\n{file_path}")
            
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Error:\n{str(e)}")
    
    # ==================== ESTILOS ====================
    
    def get_tool_button_style(self):
        return """
            QPushButton {
                background-color: #F0F0F0;
                border: 1px solid #E0E0E0;
                border-radius: 5px;
                padding: 8px 16px;
                font-size: 13px;
            }
            QPushButton:hover {
                background-color: #E8E8E8;
                border-color: #0078D7;
            }
            QPushButton:pressed {
                background-color: #D0D0D0;
            }
        """
    
    def get_zoom_button_style(self):
        return """
            QPushButton {
                background-color: white;
                border: 1px solid #E0E0E0;
                border-radius: 5px;
                padding: 5px 10px;
                font-size: 14px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #F5F5F5;
                border-color: #0078D7;
            }
        """
    
    def apply_style(self):
        self.setStyleSheet("""
            QMainWindow {
                background-color: #F0F0F0;
            }
            QMenuBar {
                background-color: white;
                border-bottom: 1px solid #E0E0E0;
                padding: 5px;
            }
            QMenuBar::item:selected {
                background-color: #E3F2FD;
                color: #0078D7;
            }
            QMenu {
                background-color: white;
                border: 1px solid #E0E0E0;
            }
            QMenu::item:selected {
                background-color: #E3F2FD;
                color: #0078D7;
            }
            QStatusBar {
                background-color: white;
                border-top: 1px solid #E0E0E0;
            }
        """)
    
    def show_about(self):
        QMessageBox.about(
            self,
            "Canvas Editor v3.0",
            """
            <h2>Canvas Editor v3.0</h2>
            <p><b>Sistema de Handles Profesional</b></p>
            
            <h3>‚ú® Caracter√≠sticas:</h3>
            <ul>
                <li>üîµ 8 handles azules de redimensi√≥n</li>
                <li>üü¢ Handle verde de rotaci√≥n</li>
                <li>üìê Tooltips con dimensiones/√°ngulo</li>
                <li>‚å®Ô∏è Modificadores: Shift (snap) y Alt (deformar)</li>
                <li>üéØ Cursores apropiados</li>
                <li>üìã Panel de capas en tiempo real</li>
            </ul>
            
            <h3>üéØ Uso:</h3>
            <p><b>Esquinas azules:</b> mantienen proporci√≥n por defecto</p>
            <p><b>Alt + esquina:</b> deformar libremente</p>
            <p><b>Lados azules:</b> estiran en esa direcci√≥n</p>
            <p><b>Handle verde:</b> rotar imagen</p>
            <p><b>Shift + rotar:</b> ajustar a 15¬∞</p>
            
            <p>¬© 2025 Canvas Editor Team</p>
            """
        )

# ==================== MAIN ====================

def main():
    app = QApplication(sys.argv)
    app.setApplicationName("Canvas Editor v3.0")
    app.setStyle(QStyleFactory.create('Fusion'))
    
    window = CanvasEditor()
    window.show()
    
    sys.exit(app.exec())

if __name__ == "__main__":
    main()
